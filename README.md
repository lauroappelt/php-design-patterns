# Design patterns

### O que são design patterns?
* Padrões de projeto são soluções genéricas para problemas recorrentes do desenvolvimento de software
* Existem três principais categorias de padrões de projeto
    * Comportamentais:
    Esses padrões se concentram nas interações entre objetos e como eles comunicam e colaboram uns com os outros. Eles ajudam a tornar o sistema mais flexível e fácil de entender. Alguns exemplos incluem o padrão <b>Observer, Strategy e Command</b>
        <br>
    * Estruturais
    Esses padrões lidam com a composição de classes e objetos para formar estruturas maiores. Eles ajudam a garantir que os sistemas sejam escaláveis e fáceis de modificar. Alguns exemplos são o padrão <b>Adapter, Bridge e Composite</b>
    <br>
    * Criacionais
    Estes padrões tratam da criação de objetos de forma apropriada para a situação, ajudando a garantir que o sistema seja flexível e fácil de manter. Exemplos incluem o padrão <b>Singleton, Factory Method e Abstract Factory</b>.
##### Strategy
Como diminuir a complexidade do nosso código, trocando múltiplas condicionais por classes
[https://refactoring.guru/design-patterns/strategy](https://refactoring.guru/design-patterns/strategy)

##### Chain of Responsability
O padrão Chain of Responsibility é um padrão comportamental que permite que você passe solicitações por uma cadeia de manipuladores. Cada manipulador decide se processa a solicitação ou a passa para o próximo manipulador na cadeia

[https://refactoring.guru/pt-br/design-patterns/chain-of-responsibility](https://refactoring.guru/pt-br/design-patterns/chain-of-responsibility)

##### Template method

Template method é um padrão comportamental que define a estrutura de um algoritmo em uma classe base, mas permite que as subclasses substituam partes desse algoritmo sem alterar sua estrutura geral, dessa forma é fácil reutilizar código comum.

[https://refactoring.guru/design-patterns/template-method](https://refactoring.guru/design-patterns/template-method)

##### State method

O padrão State tem como objetivo permitir que um objeto altere seu comportamento interno quando seu estado muda. Isso é útil quando um objeto pode estar em um de vários estados e precisa executar diferentes ações com base em seu estado atual.

[https://refactoring.guru/design-patterns/state](https://refactoring.guru/design-patterns/state)

##### Command

[https://refactoring.guru/pt-br/design-patterns/command](https://refactoring.guru/pt-br/design-patterns/command)

##### Observer

[https://refactoring.guru/pt-br/design-patterns/observer](https://refactoring.guru/pt-br/design-patterns/observer)
